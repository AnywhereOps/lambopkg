{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"lambopkg","text":"<p>This project is for running Autopkg and importing into munki as well as promoting new versions through munki catalogs</p>"},{"location":"autopromote/","title":"Autopromote","text":""},{"location":"autopromote/#about","title":"About","text":"<p>autopromote.py is run on cron on a munki_repo server. It promotes packages between catalogs in an order and on a schedule configured in autopromote.json.</p> <p>The script works by storing a \"last_promoted\" datetime in the _metadata array on all pkginfo.plist files it promotes.</p> <p>Autopromote should be run daily, and operates on a promotion schedule of days. Admins may configure a schedule of catalogs, each with a package lifetime and a force install period. Admins may also specify different promotion speeds - channels, specific patch days, and specific force install times.</p>"},{"location":"autopromote/#setup","title":"Setup","text":"<ol> <li><code>mkdir .venv &amp;&amp; virtualenv .venv &amp;&amp; source .venv/bin/activate</code> (py 2.7)</li> <li><code>pip install -r requirements.txt</code></li> <li><code>python3 autopromote.py</code> (or cron to this effect)</li> </ol>"},{"location":"autopromote/#config","title":"Config","text":""},{"location":"autopromote/#catalogs","title":"catalogs","text":"<p>A schedule of catalogs. Each should define the number of days a pkginfos should live in this catalog, and the next catalog. If <code>next</code> is null, the catalog is assumed to be the final catalog, no matter the <code>days</code> defined.</p>"},{"location":"autopromote/#denylist","title":"denylist","text":"<p>A dictionary of package_name: package_version_regex to refuse to promote. If the version is <code>null</code>, promotions for all versions are blocked.</p> <p>To block promoting all versions of BlueJeans and just 5.x versions of Zoom, set:</p> <pre><code>\"denylist\": {\n    \"Zoom\": \"5.*\",\n    \"BlueJeans\": null\n}\n</code></pre>"},{"location":"autopromote/#allowlist","title":"allowlist","text":"<p>A dictionary of package_name: package_version_regex to refuse to promote. If a package_name is set but, promotions which do not match package_version_regex will be blocked.</p> <p>To allow only 8.x versions of Teleport, set:</p> <pre><code>\"allowlist\": {\n    \"Teleport\": \"8.*\"\n}\n</code></pre>"},{"location":"autopromote/#munki_repo","title":"munki_repo","text":"<p>full path to the root munki_repo.</p>"},{"location":"autopromote/#fields_to_copy","title":"fields_to_copy","text":"<p>when a pkginfo is promoted for the first time (no <code>last_promoted</code> value is set), autopromote.py searchs for a previous semantic version of the pkginfo. If found, any/all of the fields in this array are copied to the newly promoted pkginfo.</p>"},{"location":"autopromote/#force_install_days","title":"force_install_days","text":"<p>If set, all newly promoted pkginfos receive a fresh force_install_after_date matching a T+this value. This is the default, to configure for specific packages use the <code>catalogs</code> hash.</p>"},{"location":"autopromote/#patch_tuesday","title":"patch_tuesday","text":"<p>An integer, 0-6, which specified the weekday to force force install dates to. For instance, if the force install date is 7 days from now, which falls on a Friday (4), and patch_tuesday is set to Tuesday (1), the force install date will be shifted by 4 days, to 11 days from now, in order to fall on the next Tuesday. This allows admins to automatically create a weekly predictability in their patch cycle.</p> <p>Uses Python's weekday implementation for days of the week.</p> Integer Value Day of the week 0 Monday 1 Tuesday 2 Wednesday 3 Thursday 4 Friday 5 Saturday 6 Sunday <p>A patch_tuesday of <code>null</code> will preclude any shift of force install dates.</p>"},{"location":"autopromote/#force_install_time","title":"force_install_time","text":"<p>The hour and minute, T+force_install_days, at which force install will take effect.</p> <p>Format: <code>{\"hour\": int, \"minute\": int}</code></p>"},{"location":"autopromote/#enforce_force_install_time","title":"enforce_force_install_time","text":"<p>Have you decided 4:30 is a bad force install time? Set this value to true and configure the <code>force_install_time</code> to regulate the hour and minute, and, if set, the day (<code>patch_tuesday</code>) your package force install datetimes use.</p>"},{"location":"autopromote/#enforce_force_install_date","title":"enforce_force_install_date","text":"<p>If <code>false</code>, <code>force_install_after_date</code> will not be updated in the output pkginfo(s). Neither a promotion period delta nor a <code>force_install_time</code> will be applied. The existing date, if set, will be preserved.</p>"},{"location":"autopromote/#force_install_denylist","title":"force_install_denylist","text":"<p>A list of pkginfos (as defined in their <code>name</code> attribute) on which no force_install_after_date will ever be set.</p>"},{"location":"autopromote/#channels","title":"channels","text":"<p>Channels allow one to specify a faster or slower promotion schedule for specific packages. This is a dictionary of channel names and an int or float multiplier:</p> <p><code>{\"channels\": {\"slow\": 2.5}}</code> - this channel configuration would cause any packages in the \"slow\" channel to be promoted 2.5 times slower. This is achieved by multiplying the current promotion period by the channel's value. If your promotion period is ten days, setting the slow channel to 2.5 would increase the time between promotions to twenty-five days. For faster promotion schedules, specify a float modifier of less than 1. For example, a multiplier of <code>0.5</code> would result in a 2x faster promotion schedule.</p> <p>You may add a package to a channel by adding a channel key to the pkginfo metadata dict. If no channel is specified, or if a non-float/int value is specified, the channel modifier is always 1. A package in the \"slow\" channel would have this in its pkginfo:</p> <pre><code>&lt;key&gt;_metadata&lt;/key&gt;\n&lt;dict&gt;\n    &lt;key&gt;channel&lt;/key&gt;\n    &lt;string&gt;slow&lt;/string&gt;\n&lt;/dict&gt;\n</code></pre> <p>If you're using AutoPkg you can configure this in your recipe override, so all versions of a package enter the same channel. Place the channel info in the <code>Input</code> section of your recipe override:</p> <pre><code>&lt;key&gt;metadata_additions&lt;/key&gt;\n&lt;dict&gt;\n    &lt;key&gt;channel&lt;/key&gt;\n    &lt;string&gt;slow&lt;/string&gt;\n&lt;/dict&gt;\n</code></pre>"},{"location":"modules/","title":"Modules Reference","text":""},{"location":"modules/#runnersautopkg_tools","title":"runners.autopkg_tools","text":""},{"location":"modules/#lambopkg.runners.autopkg_tools.process_recipe","title":"<code>process_recipe(recipe_path, git_repo_root, munki_subdir, gh_repo, token, settings, autopkg_prefs)</code>  <code>async</code>","text":"<p>Run recipe in isolated worktree, commit, push, create PR.</p> Source code in <code>lambopkg/runners/autopkg_tools.py</code> <pre><code>async def process_recipe(\n    recipe_path: Path,\n    git_repo_root: Path,\n    munki_subdir: str,\n    gh_repo: str,\n    token: str,\n    settings: Settings,\n    autopkg_prefs: AutoPkgPrefs,\n) -&gt; None:\n    \"\"\"Run recipe in isolated worktree, commit, push, create PR.\"\"\"\n    logger = logging_config.get_logger(__name__)\n    recipe_name = recipe_path.stem\n\n    logger.info(\"Processing %s\", recipe_name)\n\n    now = datetime.now(timezone.utc)\n    branch = f\"autopkg-{recipe_name.replace(' ', '-')}-{now:%Y%m%d%H%M%S}\"\n    worktree_path = git_repo_root.parent / f\"worktree-{recipe_name}-{now:%Y%m%d%H%M%S}\"\n\n    # Clone prefs and point at worktree's munki subdir\n    prefs = autopkg_prefs.clone()\n    prefs.munki_repo = worktree_path / munki_subdir\n\n    base_repo = Repo(git_repo_root)\n\n    with worktree(base_repo, worktree_path, branch) as wt_repo:\n        # Run recipe with prefs pointing to worktree\n        with prefs:\n            try:\n                results = await Recipe(recipe_path, settings.report_dir, prefs).run()\n                logger.debug(\"AutoPkg recipe run results: %s\", results)\n                logger.info(\"Recipe run %s complete\", recipe_name)\n            except Exception:\n                logger.exception(\"Recipe %s failed\", recipe_name)\n                return\n\n        if not results[\"munki_imported_items\"]:\n            logger.info(\"No changes for %s\", recipe_name)\n            return\n\n        # Stage metadata files for git (packages are gitignored, synced to S3 separately)\n        munki_repo_path = str(prefs.munki_repo)\n        for item in results[\"munki_imported_items\"]:\n            files = [f\"{munki_repo_path}/pkgsinfo/{item.get('pkginfo_path')}\"]\n            if item.get(\"icon_repo_path\"):\n                files.append(f\"{munki_repo_path}/icons/{item.get('icon_repo_path')}\")\n            wt_repo.index.add(files)\n\n        # Catch any untracked icons (some recipes produce icons without setting icon_repo_path)\n        icons_dir = f\"{munki_repo_path}/icons\"\n        if os.path.isdir(icons_dir):\n            wt_repo.index.add([icons_dir])\n\n        # Commit and push\n        name = results[\"munki_imported_items\"][0][\"name\"]\n        version = results[\"munki_imported_items\"][0][\"version\"]\n        commit_msg = f\"AutoPkg {name} {version}\"\n\n        wt_repo.index.commit(commit_msg)\n        wt_repo.remote(\"origin\").push(refspec=f\"{branch}:{branch}\")\n        logger.info(\"Pushed branch %s\", branch)\n\n        # Create PR via PyGithub\n        gh = Github(auth=Auth.Token(token))\n        pr = gh.get_repo(gh_repo).create_pull(\n            title=f\"AutoPkg: {name} {version}\",\n            body=f\"Automated update for `{name}` version `{version}`.\",\n            head=branch,\n            base=\"main\",\n        )\n        logger.info(\"Created PR: %s\", pr.html_url)\n        gh.close()\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopkg_tools.worktree","title":"<code>worktree(repo, path, branch)</code>","text":"<p>Create git worktree for isolated recipe processing.</p> Source code in <code>lambopkg/runners/autopkg_tools.py</code> <pre><code>@contextmanager\ndef worktree(repo: Repo, path: Path, branch: str):\n    \"\"\"Create git worktree for isolated recipe processing.\"\"\"\n    repo.create_head(branch)\n    repo.git.worktree(\"add\", str(path), branch)\n    try:\n        yield Repo(path)\n    finally:\n        repo.git.worktree(\"remove\", str(path), \"--force\")\n        repo.git.worktree(\"prune\")\n</code></pre>"},{"location":"modules/#runnersautopromote","title":"runners.autopromote","text":""},{"location":"modules/#lambopkg.runners.autopromote.get_channel_multiplier","title":"<code>get_channel_multiplier(plist)</code>","text":"<p>Retrieve the float multiplier for plist's channel. Returns multiplier or 1</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_channel_multiplier(plist):\n    \"\"\"Retrieve the float multiplier for plist's channel. Returns multiplier or 1\"\"\"\n\n    channel = plist.get(\"_metadata\", {}).get(\"channel\")\n    if channel is None:\n        return 1.0\n\n    multiplier = CONFIG.get(\"channels\", {}).get(channel)\n    if not isinstance(multiplier, (int, float)) or multiplier == 0:\n        return 1.0\n\n    return float(multiplier)\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_force_install_days","title":"<code>get_force_install_days(catalog)</code>","text":"<p>Returns the number of days a package should live in a catalog, as configured</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_force_install_days(catalog):\n    \"\"\"Returns the number of days a package should live in a catalog, as configured\"\"\"\n\n    days = CONFIG[\"catalogs\"].get(catalog, {}).get(\"force_install_days\")\n    if not isinstance(days, int):\n        days = CONFIG[\"force_install_days\"]\n\n    return days\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_force_install_time","title":"<code>get_force_install_time(plist)</code>","text":"<p>Returns a force install datetime shifted to match the configured force_install_time</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_force_install_time(plist):\n    \"\"\"Returns a force install datetime shifted to match the configured force_install_time\"\"\"\n\n    f = arrow.get(plist[\"force_install_after_date\"])\n    r = f.shift(\n        hours=(int(CONFIG[\"force_install_time\"][\"hour\"] or 0) - f.hour),\n        minutes=(int(CONFIG[\"force_install_time\"][\"minute\"] or 0) - f.minute),\n    )\n\n    patch_day = CONFIG.get(\"patch_tuesday\")\n    if isinstance(patch_day, int) and patch_day &lt;= 6 and patch_day &gt;= 0:\n        r = r.shift(weekday=patch_day)\n\n    return r.datetime\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_ideal_catalogs","title":"<code>get_ideal_catalogs(catalogs)</code>","text":"<p>Given a list of catalogs, returns the catalog which appears last in CONFIG['catalog_order'] and and the list of catalogs leading up to that catalog</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_ideal_catalogs(catalogs):\n    \"\"\"\n    Given a list of catalogs, returns the catalog which appears last\n    in CONFIG['catalog_order'] and and the list of catalogs leading up to that catalog\n    \"\"\"\n\n    custom_catalogs = [c for c in catalogs if c not in CONFIG[\"catalog_order\"]]\n    config_catalogs = [c for c in CONFIG[\"catalog_order\"] if c in catalogs]\n    latest_catalog = None if not config_catalogs else config_catalogs[-1]\n\n    if latest_catalog:\n        new_catalogs = []\n        for c in CONFIG[\"catalog_order\"]:\n            new_catalogs.append(c)\n            if c == latest_catalog:\n                break\n\n        new_catalogs = new_catalogs + custom_catalogs\n    else:\n        new_catalogs = catalogs\n\n    return latest_catalog, new_catalogs\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_next_catalog","title":"<code>get_next_catalog(latest_catalog)</code>","text":"<p>Returns the next catalog configured in the promotion schedule</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_next_catalog(latest_catalog):\n    \"\"\"Returns the next catalog configured in the promotion schedule\"\"\"\n\n    for i, catalog in enumerate(CONFIG[\"catalog_order\"]):\n        if catalog == latest_catalog:\n            try:\n                return CONFIG[\"catalog_order\"][i + 1]\n            except IndexError:\n                return None\n\n    return None\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_pkgs","title":"<code>get_pkgs(root)</code>","text":"<p>Returns a list of pkginfo paths given a root directory.</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_pkgs(root):\n    \"\"\"Returns a list of pkginfo paths given a root directory.\"\"\"\n\n    pkgs = []\n    for directory, _subdirs, pkginfos in os.walk(root):\n        for pkginfo in pkginfos:\n            pkgs.append(os.path.join(directory, pkginfo))\n    return pkgs\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.get_previous_pkg","title":"<code>get_previous_pkg(current)</code>","text":"<p>Returns the previous version of package in PKGINFOS_PATHS</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def get_previous_pkg(current):\n    \"\"\"Returns the previous version of package in PKGINFOS_PATHS\"\"\"\n\n    last = None\n    current_version = pkg_version(current)\n    for plist, _pkginfo in PKGINFOS_PATHS:\n        if plist[\"name\"] == current[\"name\"] and plist[\"version\"] != current[\"version\"]:\n            plist_version = pkg_version(plist)\n            if last:\n                last_version = pkg_version(last)\n                last = last if plist_version &lt; last_version else plist if plist_version &lt; current_version else last\n            else:\n                last = plist\n    if last:\n        logger.debug(\n            f\"Determined that previous version of {current['name']} {current['version']} is {last['name']} {last['version']}\"\n        )\n    else:\n        logger.warning(f\"found no previous packages for {current['name']}\")\n\n    return last\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.load_config","title":"<code>load_config()</code>","text":"<p>Reads autopromote.json from hardcoded path CONFIG_FILE</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def load_config():\n    \"\"\"Reads autopromote.json from hardcoded path CONFIG_FILE\"\"\"\n\n    with open(CONFIG_FILE) as f:\n        config = json.load(f)\n\n    config[\"catalogs\"], config[\"catalog_order\"] = order_catalogs(config[\"catalogs\"])\n    config = load_deny_and_allow_lists(config)\n    return config\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.load_logger","title":"<code>load_logger(logfile)</code>","text":"<p>Returns logger object pointing to stdout or a file, as configured</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def load_logger(logfile):\n    \"\"\"Returns logger object pointing to stdout or a file, as configured\"\"\"\n\n    logger = logging.getLogger(\"autopromote\")\n    level = logging.DEBUG if DEBUG else logging.INFO\n\n    formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n\n    if logfile == \"stdout\":\n        handler = StreamHandler(sys.stdout)\n    else:\n        handler = RotatingFileHandler(logfile, maxBytes=1000000, backupCount=10)\n\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    return logger\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.notify_slack","title":"<code>notify_slack(promotions, error)</code>","text":"<p>Given a list of results from promote_pkgs, send a slack alert with a summary</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def notify_slack(promotions, error):\n    \"\"\"\n    Given a list of results from promote_pkgs, send a slack alert with a summary\n    \"\"\"\n\n    # Generate our Slack WebClient\n    token = os.environ.get(\"SLACK_TOKEN\")\n    sslcert = SSLContext(PROTOCOL_TLS_CLIENT)\n    sslcert.load_verify_locations(certifi.where())\n    client = WebClient(token=token, ssl=sslcert)\n    if not token:\n        logger.error(\"No SLACK_TOKEN is in environment, skipping slack output\")\n        return\n    # Build out the Slack message attachment showing what was promoted\n    attachments = {\n        \"fields\": [\n            {\"title\": pkg, \"value\": f\"{result['from']} =&gt; {result['to']}\"} for pkg, result in promotions.items()\n        ],\n        \"color\": \"danger\" if error else \"good\",\n        \"title\": \"Autopromotion run completed\",\n        \"text\": \"\" if promotions else \"No packages promoted\" if not error else f\"Error: {error}\",\n        \"footer\": \"Alerts #withGusto\",\n    }\n    logger.debug(promotions)\n    logger.debug(attachments)\n    # Actually send the Slack message\n    try:\n        client.chat_postMessage(\n            channel=CONFIG.get(\"slack_channel\", \"#test-please-ignore\"),\n            text=\"new autopromote.py run complete\",\n            username=\"munki autopromoter\",\n            icon_emoji=\":munki:\",\n            attachments=[attachments],\n        )\n    except SlackApiError as e:\n        logger.exception(f\"Slack error: {e.response['error']}\")\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.order_catalogs","title":"<code>order_catalogs(catalogs)</code>","text":"<p>Takes a list of catalogs and returns a dict ordered according the configured catalog schedule.</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def order_catalogs(catalogs):\n    \"\"\"\n    Takes a list of catalogs and returns a dict ordered according the\n    configured catalog schedule.\n    \"\"\"\n\n    od = OrderedDict()\n    keys = []\n    keys_to_process = catalogs.keys()\n\n    while keys_to_process:\n        still_to_process = []\n        for catalog in keys_to_process:\n            definition = catalogs[catalog]\n            nxt = definition[\"next\"]\n\n            if nxt is None:\n                keys.insert(-1, catalog)\n\n            elif nxt in keys:\n                i = keys.index(nxt) - 1\n                i = 0 if i == -1 else i\n                keys.insert(i, catalog)\n            else:\n                still_to_process.append(catalog)\n\n        keys_to_process = still_to_process.copy()\n\n    for key in keys:\n        od[key] = catalogs[key].copy()\n\n    return od, keys\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.output_results","title":"<code>output_results(promotions, error)</code>","text":"<p>Given a list of results from promote_pkgs, write a file to disk</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def output_results(promotions, error):\n    \"\"\"\n    Given a list of results from promote_pkgs, write a file to disk\n    \"\"\"\n\n    file_path = CONFIG.get(\"output_results_path\", \"results.plist\")\n\n    with open(file_path, \"wb\") as f:\n        if error:\n            plistlib.dump(error, f)\n        else:\n            plistlib.dump(promotions, f)\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.pkg_version","title":"<code>pkg_version(plist)</code>","text":"<p>Returns parsed semantic version from plist</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def pkg_version(plist):\n    \"\"\"Returns parsed semantic version from plist\"\"\"\n\n    return semantic_version.parse(plist[\"version\"])\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.promote_pkg","title":"<code>promote_pkg(current_plist, path)</code>","text":"<p>Given a pkginfo plist, parse its catalogs, apply a new catalog (promotion) and shift force_install_after_date if neccessary.</p> <p>Returns a boolean promoted and a dict results</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def promote_pkg(current_plist, path):  # noqa: C901\n    \"\"\"\n    Given a pkginfo plist, parse its catalogs, apply a new catalog (promotion)\n    and shift force_install_after_date if neccessary.\n\n    Returns a boolean promoted and a dict results\n    \"\"\"\n\n    name = current_plist[\"name\"]\n    version = current_plist[\"version\"]\n    catalogs = current_plist[\"catalogs\"]\n    fullname = f\"{name} {version}\"\n    plist = current_plist.copy()\n\n    promoted = False\n    result = {\"plist\": plist, \"from\": None, \"to\": None, \"fullname\": fullname}\n\n    logger.info(f\"Considering package {fullname}\")\n\n    if not permitted(name, version):\n        return promoted, result\n\n    if (\n        CONFIG[\"enforce_force_install_time\"]\n        and CONFIG.get(\"force_install_time\")\n        and plist.get(\"force_install_after_date\")\n    ):\n        plist[\"force_install_after_date\"] = get_force_install_time(plist)\n\n    latest_catalog, ideal_catalogs = get_ideal_catalogs(catalogs)\n    plist[\"catalogs\"] = ideal_catalogs\n\n    logger.debug(f\"Package {fullname} has a catalog of {latest_catalog}\")\n    promotion_period = CONFIG[\"catalogs\"].get(latest_catalog, {}).get(\"days\")\n    logger.debug(f\"Promotion period for package {fullname} is {promotion_period}\")\n\n    if promotion_period is None:\n        logger.debug(f\"No defined promotion period for {latest_catalog} catalog, skipping\")\n        return promoted, result\n\n    last_promoted = plist.get(\"_metadata\", {}).get(\"last_promoted\")\n    if last_promoted is None:\n        logger.debug(f\"Package {fullname} has no last_promoted value!\")\n\n        # Is newly imported package\n        if latest_catalog == CONFIG[\"catalog_order\"][0]:\n            last_promoted = plist[\"_metadata\"].get(\"creation_date\")\n\n            previous_pkg = get_previous_pkg(plist)\n\n            if previous_pkg:\n                for key in CONFIG[\"fields_to_copy\"]:\n                    # Only copy the previous field if the new plist does not contain a conflicting value\n                    if previous_pkg.get(key) and not plist.get(key):\n                        plist[key] = previous_pkg[key]\n            else:\n                logger.info(f\"No previous package found for {fullname}!\")\n\n    last_promoted = arrow.get(last_promoted) if last_promoted else None\n\n    if last_promoted is None:\n        promotion_due = False\n    else:\n        channel_shifted = promotion_period * get_channel_multiplier(plist)\n        logger.debug(f\"Channel-shifted promotion period for {fullname} is {channel_shifted}\")\n\n        since_last_promotion = arrow.now() - last_promoted\n        days_since_last_promotion = since_last_promotion.days + since_last_promotion.seconds / SECONDS_IN_DAY\n        logger.debug(f\"{fullname} was last promoted {days_since_last_promotion} days ago\")\n\n        promotion_due = days_since_last_promotion &gt;= channel_shifted\n\n    if not promotion_due:\n        return promoted, result\n\n    next_catalog = CONFIG[\"catalogs\"][latest_catalog][\"next\"]\n    if next_catalog is None:\n        if promotion_period is not None:\n            msg = \"Cannot define a next catalog without a promotion period.\"\n            raise ValueError(msg)\n        return promoted, result\n\n    plist[\"catalogs\"].append(next_catalog)\n    promoted = True\n    result[\"pkginfo\"] = path\n    result[\"from\"] = latest_catalog\n    result[\"to\"] = next_catalog\n    plist[\"_metadata\"][\"last_promoted\"] = arrow.now().datetime\n    if CONFIG.get(\"enforce_force_install_date\") and name not in CONFIG.get(\"force_install_denylist\", []):\n        plist[\"force_install_after_date\"] = arrow.now().shift(days=+get_force_install_days(next_catalog)).datetime\n\n        if CONFIG.get(\"enforce_force_install_time\") and CONFIG.get(\"force_install_time\"):\n            plist[\"force_install_after_date\"] = get_force_install_time(plist)\n\n    logger.info(f\"Promoted {fullname} from {result['from']} to {result['to']}\")\n\n    return promoted, result\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.promote_pkgs","title":"<code>promote_pkgs(pkginfos)</code>","text":"<p>Iterate over pkgs and pass them to promote_pkg if not in denylist.</p> <p>Returns a list of results from promote_pkg.</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def promote_pkgs(pkginfos):\n    \"\"\"\n    Iterate over pkgs and pass them to promote_pkg if not in denylist.\n\n    Returns a list of results from promote_pkg.\n    \"\"\"\n\n    promotions = {}\n\n    for plist, path in pkginfos:\n        promoted, result = promote_pkg(plist, path)\n        if promoted:\n            promotions[result[\"fullname\"]] = result\n\n        with open(path, \"wb\") as f:\n            plistlib.dump(result[\"plist\"], f)\n\n        logger.debug(f\"wrote {result['fullname']} to {path}\")\n\n    return promotions\n</code></pre>"},{"location":"modules/#lambopkg.runners.autopromote.safe_read_pkg","title":"<code>safe_read_pkg(pkginfo)</code>","text":"<p>Returns the contents of a pkginfo plist, or, if a parsing error occurs, None</p> Source code in <code>lambopkg/runners/autopromote.py</code> <pre><code>def safe_read_pkg(pkginfo):\n    \"\"\"Returns the contents of a pkginfo plist, or, if a parsing error occurs, None\"\"\"\n\n    logger.info(f\"parsing {pkginfo}\")\n    try:\n        with open(pkginfo, \"rb\") as f:\n            plist = plistlib.load(f)\n    except (ExpatError, plistlib.InvalidFileException) as e:\n        # This is raised if a plist cannot be parsed (generally because its not a plist, but some clutter eg DS_Store)\n        logger.warning(f\"Failed to parse {pkginfo} because: {e!r}\")\n        plist = None\n    except Exception:\n        logger.exception(f\"Error parsing {pkginfo}\")\n        raise\n    return plist\n</code></pre>"},{"location":"modules/#runnersfix_trust_info","title":"runners.fix_trust_info","text":"<p>Fix ParentRecipeTrustInfo paths in AutoPkg override recipes.</p> <p>Scans override recipes for ParentRecipeTrustInfo entries, resolves each parent recipe identifier to its actual filesystem path by searching Overrides/ then Recipes/, and updates the path and sha256_hash fields.</p> Usage <p>python lambopkg/runners/fix_trust_info.py [--autopkg-dir AutoPkg]</p>"},{"location":"modules/#lambopkg.runners.fix_trust_info.build_identifier_index","title":"<code>build_identifier_index(autopkg_dir)</code>","text":"<p>Build map of recipe Identifier -&gt; file path.</p> Source code in <code>lambopkg/runners/fix_trust_info.py</code> <pre><code>def build_identifier_index(autopkg_dir: Path) -&gt; dict[str, Path]:\n    \"\"\"Build map of recipe Identifier -&gt; file path.\"\"\"\n    index = {}\n    for search_dir in [autopkg_dir / \"Overrides\", autopkg_dir / \"Recipes\"]:\n        if not search_dir.exists():\n            continue\n        for recipe_file in search_dir.rglob(\"*.recipe.yaml\"):\n            try:\n                data = yaml.safe_load(recipe_file.read_text())\n            except Exception:\n                continue\n            if isinstance(data, dict) and \"Identifier\" in data:\n                index[data[\"Identifier\"]] = recipe_file\n    return index\n</code></pre>"},{"location":"modules/#lambopkg.runners.fix_trust_info.fix_override","title":"<code>fix_override(override_path, index)</code>","text":"<p>Fix trust info paths in a single override. Returns True if modified.</p> Source code in <code>lambopkg/runners/fix_trust_info.py</code> <pre><code>def fix_override(override_path: Path, index: dict[str, Path]) -&gt; bool:\n    \"\"\"Fix trust info paths in a single override. Returns True if modified.\"\"\"\n    text = override_path.read_text()\n    data = yaml.safe_load(text)\n\n    if not isinstance(data, dict):\n        return False\n\n    trust_info = data.get(\"ParentRecipeTrustInfo\")\n    if not trust_info or not isinstance(trust_info, dict):\n        return False\n\n    parent_recipes = trust_info.get(\"parent_recipes\")\n    if not parent_recipes or not isinstance(parent_recipes, dict):\n        return False\n\n    modified = False\n    for identifier, info in parent_recipes.items():\n        if identifier not in index:\n            print(f\"  WARNING: {identifier} not found in Overrides/ or Recipes/\")\n            continue\n\n        resolved_path = str(index[identifier])\n        new_hash = sha256_file(index[identifier])\n\n        old_path = info.get(\"path\", \"\")\n        old_hash = info.get(\"sha256_hash\", \"\")\n\n        if old_path != resolved_path or old_hash != new_hash:\n            info[\"path\"] = resolved_path\n            info[\"sha256_hash\"] = new_hash\n            modified = True\n            if old_path != resolved_path:\n                print(f\"  {identifier}: path updated\")\n            if old_hash != new_hash:\n                print(f\"  {identifier}: hash updated\")\n\n    if modified:\n        override_path.write_text(\n            yaml.dump(data, default_flow_style=False, allow_unicode=True)\n        )\n\n    return modified\n</code></pre>"},{"location":"modules/#lambopkg.runners.fix_trust_info.sha256_file","title":"<code>sha256_file(path)</code>","text":"<p>Compute SHA-256 hash of a file.</p> Source code in <code>lambopkg/runners/fix_trust_info.py</code> <pre><code>def sha256_file(path: Path) -&gt; str:\n    \"\"\"Compute SHA-256 hash of a file.\"\"\"\n    return hashlib.sha256(path.read_bytes()).hexdigest()\n</code></pre>"}]}